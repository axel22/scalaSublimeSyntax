// SYNTAX TEST "Packages/User/scala-sublime-syntax/Scala2.sublime-syntax"

import scala.collection.mutable._
import scala.collection.immutable.{List, Set}
// ^ meta.import.scala keyword.other.import
//      ^ variable.package.scala
//                                  ! entity.name.class


package scala_syntax {
// ^ keyword.other.scoping
//      ^ entity.name.package.scala

  /**
// ^ comment.block.documentation.scala
   * Bar documentation
   * @author toto
//     ^ keyword.documentation.inventory.scala
   * @param a the content of this Bar
//     ^ keyword.documentation.parameter.scala
   * @todo finish Bar
   */
  class Bar(a: Int) {
// ^ keyword.declaration.scala
//      ^ entity.name.class.declaration
//          ^ variable.parameter
//             ^ support.type.scala
    val unbar = a
//  ^ keyword.declaration

    // this is a comment
//     ^ comment.line.double-slash.scala
    def combine(that: Bar) = Bar(this.a + that.bar)
//  ^ keyword.declaration.scala
//        ^ entity.name.function.declaration
//               ^ variable.parameter
//                     ^ support.type.scala
//                         ^ keyword.eq.scala
//                            ^ entity.name.class
//                                 ^ variable.language.scala
//                                      ^ keyword.operator.scala

    /* this is another comment
//     ^ comment.block.scala
    */
    def +=(x: Int) : Bar = Bar(a /* plus */  + x)
//  ^ keyword.declaration.scala
//       ^ entity.name.function.declaration
//         ^ variable.parameter
//             ^ support.type.scala
//                    ^ support.type.scala
//                       ^ keyword.eq.scala
//                         ^ entity.name.class
//                                  ^ comment.block.scala
//                                           ^ keyword.operator.scala
  }

  case class BarBar(a: Int = 1, b: Boolean = false) extends Bar(a)
// ^ keyword.declaration.scala
//      ^ keyword.declaration.scala
//                  ^ variable.parameter
//                           ^ constant.numeric.scala
//                              ^ variable.parameter
//                                  ^ support.type.scala
//                                           ^ constant.language.scala
//                                                    ^ keyword.declaration.scala
//                                                          ^ entity.other.inherited-class.scala

  trait Foo[T] {
    def add(t: T): T
  }

  abstract class FooBar
      extends Foo[Bar]
      with Bar(2 + 1)
  {
    val z= 1e-12
//      ^ entity.name.val.declaration
//       ^ keyword.eq.scala
//         ^ constant.numeric.scala
//             ^ constant.numeric.scala
    val y: Int = 0x3ff
//               ^ constant.numeric.scala
//                   ^ constant.numeric.scala


    val !#%&*+-/:<=>?@\^|~ : Int = 1 // all simple opchars
//  ^ keyword.declaration.scala
//              ^ entity.name.val.declaration
//                ^ entity.name.val.declaration
//                           ^ support.type.scala
//                               ^ keyword.eq.scala
//                                 ^ constant.numeric.scala
//                                   ^ comment.line.double-slash
    val !#%&*+-/:<=>?@\^ = 2
    val simpleName = 1
    val simpleName2: Float with Foo = 1
    var withDigitsAndUnderscores_ab_12_ab12 = 1
//                              ^ entity.name.val.declaration
//                                  ^ entity.name.val.declaration
//                                        ^ entity.name.val.declaration
    val wordEndingInOpChars_!^ : Int = 1
    val !^© = 1 // opchars ans symbols
    val abc_!^= : Int = 1 // mixing letters and symbols
    def abc_*^= : Int = 1

    def abc_^= : Foo[Bar]
//  ^ keyword.declaration.scala
//               ^ support.type.scala
//                   ^ support.type.scala

    @tailrec
//  ^ entity.name.tag
    def abc(a: Int)(implicit b: Boolean) : Int =
//  ^ keyword.declaration.scala
//      ^ entity.name.function.declaration
//          ^ variable.parameter
//              ^ support.type.scala
//                     ^ storage.modifier.other
//                           ^ variable.parameter
      if(b) 1 else abc(a - 1)(a < 0)

    def printMessage(foo: Foo, a: Int) =
      println(s"Foo: $foo, n: ${a + 2}")
  }

  trait Readable[T] {
    type Tbis = T
    def read(s: String): Option[T]
  }

  class Endo[T] extends Function1[T, T] {
    def comp(that: Endo[T]) = new Endo[T]{
      def apply(x: T) = this(that(x))
    }
  }

  case class Foo[T](a: T, n: Int = 0 + 1)
    extends FooBar(n + 1) with Bar

  case class ScalaBook(version: Double, authors: List[String])

  object Main extends App {
    val x = 2 + 5 - 1 * 0x3ff - 1515497995213545l
    val f = x => x + 5 / 2f * 2.0f * 1.98 * 1e-12 * 1.01E+15

    if (1 + 1 == 2) println("Bazinga!")
    else println("***stack underflow error***")

    for(i <- 0 to 10)
        println(i)

    var leet = Map(
      'e' -> 3, 'a' -> 4, 's' -> 5
    )

    val chars = List('a', 'oko', '\n', '\u0002', '\', '\\', '1')

    val how = "how"
    val e = "e"
    val quotes = List(
      "\"It is the obvious which is so difficult to see most of the time.\n",
      "People say 'It's as plain as the nose on your face.' /* fake comment */",
      s" But $how much of the nose on your face can you s${e + e}, \unless someone holds a mirror up to you?”",
    )

    val laws = """
      |1: A robot may not injure a human being or, through inaction, allow a human being to come to harm;
      |2: A robot must obey the orders given it by human beings except where such orders would conflict with the First Law;
      |3: A robot must protect its own existence as long as such protection does not conflict with the First or Second Law;
    """.stripMargin

    val bar = new Bar(2)
    val barbar = new BarBar(1, b = 2)
    val interpolated = s"${barbar + 1} and $bar love to go to the be\u1ea1ch."

    val x = 3.054e2
    val formatted1 = f"x: $x%+,.3f ca"
    val formatted2 = f"date: $x%T \u0002 \124 \ "
    val raw_string = raw"toto\u1221n\125\n"

    private def read[T <: Readable[T] ](x: T, expr_!: : String, start: Int): T = {
      val maybeRes : Option[T] = x.read(expr_!:.substring(start))

      res match {
        case Some(y) => y
        case _ => throw new Exception("Can't parse: " + expr_!:)
      }
    }

    val scalaBook = new ScalaBook(0.1, List(" Martin Odersky"))

    val b =  <book>
          <title>The Scala Language Specification</title>
          <version>{scalaBook.version + 1}</version>
          <authors>{scalaBook.authors}</authors>
        </book>
        </book>

}
