// SYNTAX TEST "Packages/User/scala-sublime-syntax/Scala2.sublime-syntax"

import scala.collection.mutable._
import scala.collection.immutable.{List => MutList, Set => _}
// ^ meta.import.scala keyword.other.import
//      ^ variable.package.scala
//          ^ punctuation.separator.dot
//                                ^ punctuation.definition.module-binding.begin
//                                          ^ entity.name.class
//                                                          ^ punctuation.definition.module-binding.end

/** top level scala doc */
// <- comment.block.documentation.scala
package scala_syntax {
// ^ keyword.other.scoping
//      ^ entity.name.package.scala

  /**
// ^ comment.block.documentation.scala
   * Bar documentation
   * @author toto
//     ^ keyword.documentation.inventory.scala
   * @param a the content of this Bar
//     ^ keyword.documentation.parameter.scala
   * @todo finish Bar
   */
  class Bar(protected a: Int) {
//  ^ storage.type.class.class
//      ^ entity.name.class
//          ^ storage.modifier.other
//                    ^ variable.parameter
//                       ^ variable.other.type
//                            ^ punctuation.definition.class.body.begin
    val unbar = MutList(1)
//  <- meta.class.scala
//  ^ storage.type.variable.val.scala
//        ^ entity.name.val

    // this is a comment
//     ^ comment.line.double-slash.scala
    def combine(that: Bar) = Bar(this.a + that.bar)
//  ^ storage.type.function
//        ^ entity.name.function
//               ^ variable.parameter
//                     ^ variable.other.type
//                         ^ punctuation.definition.function.declaration
//                                 ^ variable.language.scala
//                                      ^ keyword.operator.scala

    /* this is another comment
//     ^ comment.block.scala
    */
    def +=(x: Int) : Bar = Bar(a /* plus */  + x)
//  ^ storage.type.function
//       ^ entity.name.function
//         ^ variable.parameter
//             ^ variable.other.type
//                    ^ variable.other.type
//                       ^ punctuation.definition.function.declaration
//                         ^ variable.type.constructor
//                                  ^ comment.block.scala
//                                           ^ keyword.operator.scala
  }
//^ punctuation.definition.class.body.end

  case class BarBar(a: Int = 1, b: Boolean = false) extends Bar(a)
//  ^ storage.type.class.case-class
//      ^ storage.type.class.case-class
//           ^ entity.name.class
//                  ^ variable.parameter
//                           ^ constant.numeric.scala
//                              ^ variable.parameter
//                                  ^ variable.other.type
//                                           ^ constant.language.scala
//                                                    ^ storage.modifier.extends.scala
//                                                          ^ entity.other.inherited-class.scala

  trait Foo[T] {
    def add(t: T): T
// <- meta.class.scala
  }

  abstract class FooBar
      extends Foo[Bar]
//      ^ storage.modifier.extends.scala
      with Bar(2 + 1)
//      ^ storage.modifier.extends.scala
  {
    val z= 1e+12f
//      ^ entity.name.val
//       ^ keyword.operator.assignment
//         ^ constant.numeric.scala
//             ^ constant.numeric.scala
    val y: Int = 0.1
//  ^ storage.type.variable.val.scala
//       ^ punctuation.separator.key-value.type.scala
//                ^ constant.numeric.scala
//                 ^ constant.numeric.scala


    var !#%&*+-/:<=>?@\^|~ : Int = 1 // all simple opchars
//  ^ storage.type.variable.var.scala
//              ^ entity.name.val.scala
//                ^ entity.name.val.scala
//                           ^ variable.other.type
//                               ^ keyword.operator.assignment
//                                 ^ constant.numeric.scala
//                                   ^ comment.line.double-slash
    val !#%&*+-/:<=>?@\^ = 2.15f
    val simpleName = 1
    val simpleName2: Float with Foo = 1
    var withDigitsAndUnderscores_ab_12_ab12 = 1
//                               ^ entity.name.val
//                                  ^ entity.name.val
//                                        ^ entity.name.val
    val wordEndingInOpChars_!^ : Int = 1
    val !^© = 1 // opchars ans symbols
//        ^ entity.name.val
    val abc_!^= : Int = 1 // mixing letters and symbols
//            ^ entity.name.val
    def abc_*^= : Int = 1
//            ^ entity.name.function

    def abc_^= : Foo[Bar]
//  ^ storage.type.function
//           ^ entity.name.function
//               ^ variable.other.type
//                  ^ punctuation.definition.arguments.begin.scala
//                   ^ variable.other.type
//                      ^ punctuation.definition.arguments.end.scala

    val List((x1: Int, y1), (x2, y2)) = ((10, 5), (1, 2))
//  ^ storage.type.variable.val.scala
//      ^ variable.type.constructor.unapply
//          ^ punctuation.definition.comprehension.array.begin
//           ^ punctuation.definition.comprehension.array.begin
//            ^ entity.name.val.scala
//              ^ punctuation.separator.key-value.type.scala
//                   ^ punctuation.separator.array-element
//                     ^ entity.name.val.scala
//                       ^ punctuation.definition.comprehension.array.end
//                        ^ punctuation.separator.array-element
//                          ^ punctuation.definition.comprehension.array.begin
//                                 ^ punctuation.definition.comprehension.array.end
//                                  ^ punctuation.definition.comprehension.array.end
//                                    ^ keyword.operator.assignment

    val Some(x) = f()         // a pattern definition
//  ^ storage.type.variable.val.scala
    val x :: xs = List(1, 2, 3)      // an infix pattern definition
//  ^ storage.type.variable.val.scala
//      ^ entity.name.val.scala
//        ^ keyword.operator.infix-pattern
//           ^ entity.name.val.scala
//              ^ keyword.operator.assignment
//                      ^ punctuation.separator.argument
    var (x: Int) :: (xs: List[Int]) = List(1, 2, 3)
//  ^ storage.type.variable.var.scala
//       ^ entity.name.val.scala
//               ^ keyword.operator.infix-pattern
//                   ^ entity.name.val.scala
//                                  ^ keyword.operator.assignment
    @tailrec
//  ^ entity.name.tag
    def abc(a: Int)(implicit b: Boolean) : Int =
//  ^ storage.type.function
//      ^ entity.name.function
//          ^ variable.parameter
//              ^ variable.other.type
//                 ^ punctuation.definition.arguments.begin.scala
//                     ^ storage.modifier.other
//                           ^ variable.parameter
//                                     ^ punctuation.definition.arguments.end.scala
//                                       ^ punctuation.separator.key-value.type.scala
//                                             ^ punctuation.definition.function.declaration.scala
      if (b) ) 1 else abc(a - 1, a)(a < 0)
//           ^ invalid.illegal

    /** Prints the message with the given foo
      * @tparam F the type of the given foo
//    ^ comment.block.documentation.scala
//      ^ keyword.documentation.parameter.scala
//              ^ variable.other.type
      */
    def printMessage[F <: Foo](foo: F, a: Int) =
      println(s"Foo: $foo, n: ${a + 2}")
//  ^ string.unquoted.block-indent
//       ^ support.function.builtin.scala
//            ^ punctuation.definition.string.interpolated.begin.scala
//                   ^ punctuation.definition.string.interpolated.element.scala
//                    ^ source string source
//                            ^ punctuation.definition.string.interpolated.element.begin.scala
//                                   ^ punctuation.definition.string.interpolated.element.end.scala
//                                    ^ punctuation.definition.string.interpolated.end.scala
  }

  trait Readable[T] {
    type Tbis = T
    def read(s: String): Option[T] = 1
  }

  class Endo[T] extends Function1[T, T] {
    def comp(that: Endo[T]) = new Endo[T]{
      def apply(x: T) = this(that(x))
    }
  }

  case class Foo[T](a: T, n: Int = 0 + 1)
    extends FooBar(n + 1) with Bar

  case class ScalaBook(version: Double, authors: List[String])

  object Main extends App {
    val x = 2 + 5 - 1 * 0x3ff - 1515497995213545l
    val f = x => x + 5 / 2f * 2.0f * 1.98 * 1e-12 * 1.01E+15

    if (1 + 1 == 2) println("Bazinga!")
//                  ^ support.function.builtin.scala
    else println("***stack underflow error***")

    for(i <- 0 to 10)
        println(i)

    var leet = Map(
      'e' -> 3, 'a' -> 4, 's' -> 5
    )

    val chars = List('a', 'oko', '\n', '\u0002', '\', '\\', '1')
//               ^ support.class.builtin.scala
    val how = "how"
    val e = "e"
    val quotes = List(
      "\"It is the obvious which is so difficult to see most of the time.\n",
      "People say 'It's as plain as the nose on your face.' /* fake comment */",
      s" But $how much of the nose on your face can you s${e + e}, \unless someone holds a mirror up to you?”",
    )

    val laws = """
      |1: A robot may not injure a human being or, through inaction, allow a human being to come to harm;
      |2: A robot must obey the orders given it by human beings except where such orders would conflict with the First Law;
      |3: A robot must protect its own existence as long as such protection does not conflict with the First or Second Law;
    """.stripMargin

    val bar = new Bar(2)
    val barbar = new BarBar(1, b = 2)
    val interpolated = s"${barbar + 1} and $bar love to go to the be\u1ea1ch."
    val x = 3.054e2
    val formatted1 = f"x: $x%+,.3f ca"
    val formatted2 = f"date: $x%T \u0002 \124 \ "
    val raw_string = raw"toto\u1221n\125\n"

    private def read[T <: Readable[T] ](x: T, expr_!: : String, start: Int): T = {
      val maybeRes : Option[T] = x.read(expr_!:.substring(start))

      res match {
//    ^ variable.other
//        ^ keyword.control.switch.scala
        case Some(y) => y
//        ^ keyword.control.switch.case.scala
//                   ^ punctuation.separator.key-value.switch.scala
        case _: Int => throw new Exception("Can't parse: " + expr_!:)
      }
    }

    val scalaBook = new ScalaBook(0.1, List("Martin Odersky"))
    val b =  <book>
          <title>The Scala Language Specification</title>
          <version>{scalaBook.version + 1}</version>
          <authors>{scalaBook.authors}</authors>
        </book>
        </book>
}
